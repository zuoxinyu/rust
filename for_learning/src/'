fn main() {
    variable_and_mutability();
}

#[derive(Debug)]
struct S {
    i : i32
}

fn variable_and_mutability() {

    let mut arr = [1,2,3];
    arr[0] = 0;

    let mutable_arr = &mut [1,2,3];
    mutable_arr[0] = 1;

    let mut s = S{i:2};
    s.i = 3;

    let mutable_s = &mut S{i:0};
    (*mutable_s).i = 1;

    let i = &3;
    lifetime(i, i);

    let i = 3; // const int i = 3;
    // i = 2; // illegal, change an immutable variable
    assert_eq!(i, 3);

    let mut j = 3; // int j = 3;
    j = 4;
    assert!(j == 4);

    let ref_i = &3; // const int x = 3; const int * ref_i = x;
    // ref_i = 3;
    println!("{:p}", ref_i as * const i32);

    let mut_ref_i = &mut 3; // int x = 3; int * mut_ref_i = x;
    *mut_ref_i = 2;
    // mut_ref_i = &mut 4; // illegal

    let mut mut_binding_i = &3; //int x = 3; int * mut_binding_i = &x;
    // *mut_binding_i = 4; // illegal
    mut_binding_i = &4; // normal

    let const_s = S{i:3}; // const const_s = S{3}
    // const_s.i = 3;
    let mut mut_binding_s = S{i:3}; // S mut_binding_s{3}
    mut_binding_s.i = 0;

    let mut_ref_s = &mut S{i:3}; // S s{3}; S * const mut_ref_s = *s;
    mut_ref_s.i = 2;
    (*mut_ref_s).i = 1;

    let mut mut_binding_ref_s = &mut S{i:3}; //

}

fn lifetime<'a>(i :&'a i32, j :&i32) -> &'a i32 {
    i
}
